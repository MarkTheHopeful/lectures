# Общее
* В билете написано почти всё, что надо рассказать.
* Для каждой синтаксической конструкции должен быть приведён содержательный пример, когда это требуется или делает код проще/удобнее.
* Вас могут активно спрашивать вокруг билета: если вы сказали, что надо писать `Foo(bar)`, вас могут сразу же спросить, что будет при написании `Foo(&bar)`, вы должны ответить.
* "Не было" — не было на лекции, знать не надо, не спрашивают. Даже если было на практике.

# Обязательные знания
Если вы не знаете какие-то термины что-то из списка ниже, это автоматический неуд.

## Термины
* Свободная функция, функция-член
* Время жизни объекта: автоматическое, динамическое, статическое
* Undefined behavior: что может произойти, примеры:
  * Неинициализированная переменная: почему у неё нет никакого значения.
  * Выход за границы массива.
  * Dangling reference (висячая ссылка) при возврате из функции, при инвалидации в стандартном контейнере.
  * Разыменование `nullptr`.

## Переменные
* статическая типизация
* тип переменной
* размер переменной, размер типа
* типы <code>int</code>, <code>char</code>: типичные размеры. Например, на архитектуре <code>x86_64</code> под Linux в компиляторе <code>GCC</code>.

## Основные конструкции языков C и C++
* объявления переменных
* выражения и операторы:
  * арифметические (`+`, `-`, `*`, `/`, `%`, `+=`, `-=`, `*=`, `/=`, `%=`, `++`, `--`)
  * булевы (`<`, `<=`, `>`, `>=`, `==`, `!=`, `&&`, `||`, `!`)
  * на минимальную оценку необязательно знать: отличия постфиксных и префиксных операторов
* условные операторы `if`, `switch` (с `break` и fallthrough, включая проблему с инициализацией переменных)
* циклы `for`, `while`

## Функции
* объявление и определение функции, требуется отличать между собой (можно случайно перепутать, но после вопроса исправиться)
* вызов функции (синтаксис, не нужно знать mangling, конвенции вызовов)
* возвращаемое значение
* рекурсивный вызов

## Основные конструкции C++
* синтаксис `static_cast`
* синтаксис объявления пространств имён, обращения к элементу внутри пространства имён
* `auto` для объявления переменных
* range-based for, в том числе с `auto&` и `const auto&`
* синтаксис шаблонов, достаточный для написания минимального адаптера `stack<T>` поверх `deque`

## Классы
* определение класса, конструктор, деструктор, методы
* специальные методы (пять штук), правило нуля, правило пяти
* приватные/защищённые/публичные поля и методы
* наследование: базовый синтаксис, включая вызов конструктора базового класса

## Полиморфные классы
* виртуальные методы и их отличия от невиртуальных
* необходимость виртуального деструктора
* чисто виртуальные функции, что происходит при отсутствии `override` или `virtual`
* slicing (срезка объектов) при присваивании полиморфного класса в переменную типа "базовый класс", как защититься (хранить только ссылки/умные указатели)
* хранение полиморфных объектов в контейнерах
* `dynamic_cast` для полиморфных классов (по указателям и ссылкам)

## Const correctness
* синтаксис константных ссылок, применение при передаче аргументов
* невозможность изменять константные объекты и их поля
* const-qualifier у методов (const member function), перегрузка по const-qualifier (const overloading)

## Использование move-семантики
* эффективная инициализация полей класса из аргументов, принятых по значению или по rvalue-ссылке
* moved-from состояние у объектов: может быть не определено, может быть невозможно обнаружить, пример ошибки
* отсутствие необходимости `move` из результата функции, возвращённого по значению
* необходимость move для явной передачи владения `unique_ptr`
* почему `std::move` не выполняет никакого кода

## STL
* использование `vector` как динамического массива фиксированной длины, <code>push_back</code> и <code>emplace_back</code>
* использование `map` со стандартным компаратором, особенность <code>operator[]</code> (создаёт значение даже при чтении)
* `lower_bound`/`upper_bound`: параметры, возвращамое значение

## Си
* использование строк в стиле Си: отличия `char s[10]` и `const char *s`, преобразование в две стороны для `std::string`
* операции со строками в стиле Си: конкатенция, получение длины, безопасная альтернатива для `gets` и `scanf("%s")`
* массивы массивов в языке Си (вроде `int**`): выделение, освобождение, использование

## Исключения
* синтаксис `try`/`catch`/`throw`, включая `catch (...)` и `throw;` (но без function-try-block)
* раскрутка стека: автоматический вызов деструкторов, в том числе в `new`/`new[]`, конструкторе, конструкторах полей
* необходимость ловить исключения по ссылке
* exception safety: определения no/basic/strong/nothrow
* умение добавить базовую гарантию в произвольный код при помощи автоматических выполняемых деструкторов

## Многопоточность
* базовое использование `thread` (включая `join()`), `mutex` и `unique_lock`
* гонки: пример гонки данных и гонки при выводе на экран, как избежать, умение видеть гонки в произвольном несложном коде

# Билеты
## 1x. Продвинутый синтаксис
`14-220110`, `20-220221`, `21-220228`, `27.5-220519`, `30-220606`

TODO

### 10. Move-семантика

## 2x. Шаблоны
`14-220110`, `22-220314`, `23-220321`, `27.5-220519`

TODO

## 3x. Исключения
`15-220117`, `16-220124`, кусочки `30-220606`

TODO

## 4x. Многопоточность и сети
`17-220131`, `18-220207`, кусочки `19-220214` и `20-220221`

### 40. TCP-соединения при помощи блокирующего ввод-вывода в Boost::Asio
* Чем характеризуется TCP-соединение: две пары (хост с IPv4-адресом, порт)
* Почему порт сервера обычно фиксирован, а клиента — случаен
* Использование `boost::asio::ip::tcp::iostream` на сервере и на клиенте для создания простого эхо-сервера
* Отличия `local_endpoint()` от `remote_endpoint()`

### 41. Базовая многопоточность
* Создание потоков в C++11, передача аргументов в функцию потока по значению и ссылкам
* Joinable/detached потоки
* Гонки: при выводе на экран, по данным, одновременное чтение без записей
* Борьба с гонками: мьютексы, атомарные снимки, RAII-обёртка над мьютексом (`unique_lock`)
* Частичная потокобезопасность `cout`

### 42. Оповещение о событиях
* Формализм happens-before, неочевидные примеры нарушения и выполнения, возможный reordering
* Условные переменные: как использовать, spurious wakeup
* Реализация producer-consumer
* Ключевое слово `mutable`

### 43. Дизайн многопоточных приложений
* Deadlock, reentrant-функции, `recursive_mutex`, отделение приватного API без блокировок от публичного API с блокировками
* Взаимные блокировки и их избегание при помощи контроля порядка взятия блокировок или `scoped_lock`/`unique_lock`
* Ключевое слово `thread_local` в сравнении с глобальными переменными
* Частичная потокобезопасность `shared_ptr`
* Проблема TOCTOU

## 5x. Совместимость с языком программирования Си
`19-220214`, `24-220411`, `25-220418`, `26-220425`, кусочки `20-220221` и `27.5-220519`

### 50. Trivially Copyable
* `reinterpret_cast`, strict aliasing rule и его нарушения в C++, корректное преобразование между `int`/`float` на уровне байт
* Trivially Copyable структуры: определение, пример, использование для (де)сериализации
* Padding (выравнивание) и его отключение, последствия хранения невыровненных нетривиальных типов вроде `vector<>`
* Особенности взятия ссылок и указателей на невыровненную память (пример со `swap` полей)
* Standard Layout и Plain Old Data (POD) структуры: определение из C++11

### 51. Многомерные массивы
* C-style-arrays/массивы в стиле Си
    * Инициализация, невозможность копирования, связь с арифметикой указателей
    * Расширение компилятора variable-length-arrays (VLA)
    * Динамическое выделение/освобождение при помощи `new[]`/`delete[]`
* Тип "массив известного размера", тип "массив неизвестного размера", тип "указатель на массив", `auto`, автовывод размера в шаблонах
* Многомерные массивы, в том числе с неизвестным нулевым измерением
* Массивы массивов как многомерные массивы: выделение и освобождение за константное количество операций, использование
* `std::array<>` для упрощения операций с массивами

### 52. Указатели
* Указатели на указатели
    * Выделение, освобождение, использование: массив строк, output-параметр функции
    * Что означает `const` в разных местах указателя на указатель
    * Явные и неявные преобразования двойных (и выше) указателей: константность и наследование
* `realloc` и его безопасное использование (`s = realloc(s, 4)` небезопасно)
* Ключевое слово `restrict`
* Создание собственных opaque-указателей вместо `void*` для большей проверки типов (`27.5-220519/01-c-cpp-extern/03-opaque-reinterpret-cast`)

### 53. Обобщённые функции
* Указатели на функции
    * Синтаксис, синтаксис, использование как параметров функции (в том числе шаблонной)
    * Взятие указателя на перегруженную/шаблонную функцию при помощи `static_cast` или присваиванием в параметр/переменную фиксированного типа
    * Неявное преобразование лямдба-выражений в указатель на функцию
* Указатель `void*`
    * Явные и неявные преобразования
    * Расширение компилятора для арифметики указателей
* Указатели на функцию с параметром `void*` как альтернатива функторам с захватом; пример реализации `for_each`

### 54. Отличия Си и C++
* Комментарии и объявления переменных (особенно в C89)
* `(void)` в объявлении функции, неявные объявления функций
* Объявления своих структур (везде нужно `struct`), конвенция с `typedef`
* Выделение и освобождение памяти через `malloc`/`free` против `new`/`delete`
* Отличия между Си и C++ в преобразованиях `void*`
* Альтернативы для языковых возможностей: unnamed namespace, `*_cast<>`, `int a{}`, namespace, ссылки, `bool`, операторы копирования и перемещения, шаблоны
* Отсутствующие возможности: перегрузка функций и параметры по умолчанию, `std::vector`, исключения

### 55. Особенности и идиомы Си
* `printf`/`scanf`: ограничение буфера для `%s`, вывод `%`, получение текущей позиции в `scanf`, потенциально квадратичное время работы при использовании `scanf`
* Designated initializer для структур и массивов
* Макросы для для констант (вместо `const`) и inline-функций
* `goto` для выхода из циклов и обработки ошибок
* Union, anonymous union, anonymous struct

### 56. Взаимодействие с библиотеками на Си
* Хранение строк в POD: `char[]`, `char*`, `std::string` (`20-220221/02-trivially-copyable-strings`)
* Необходимость вручную выделять буфер под строку, небезопасность `gets`
* Конвенции выделения ресурсов и opaque-структуры: выделение пользователем (строки), выделение библиотекой (`fopen`)
* `const_cast`
* `extern "C"` и линковка программ на Си/C++, линковка со стандартной библиотекой C++, совместимые между Си/C++ заголовки

## 6x. Метапрограммирование
`27-220516`, `28-220523`, `29-220530`,

TODO

## Явно исключено
* иерархия итераторов и их виды
* `::operator new` и их перегрузка
* аллокаторы
* использование виртуального наследования для ABC (abstract base class)
* определения паттернов "Стратегия" и "Фабрика"
* преобразования между указателями на функции
* TCP: возможность не получить сообщение целиком за один вызов `receive`, почему это неважно для `tcp::iostream`
