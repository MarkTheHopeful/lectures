# Общее
* В билете написано почти всё, что надо рассказать.
* Для каждой синтаксической конструкции должен быть приведён содержательный пример, когда это требуется или делает код проще/удобнее.
* Вас могут активно спрашивать вокруг билета: если вы сказали, что надо писать `Foo(bar)`, вас могут сразу же спросить, что будет при написании `Foo(&bar)`, вы должны ответить.
* "Не было" — не было на лекции, знать не надо, не спрашивают. Даже если было на практике.

# Обязательные знания
Если вы не знаете какие-то термины что-то из списка ниже, это автоматический неуд.

## Термины
* Свободная функция, функция-член
* Время жизни объекта: автоматическое, динамическое, статическое
* Undefined behavior: что может произойти, примеры:
  * Неинициализированная переменная: почему у неё нет никакого значения.
  * Выход за границы массива.
  * Dangling reference (висячая ссылка) при возврате из функции, при инвалидации в стандартном контейнере.
  * Разыменование `nullptr`.

## Переменные
* статическая типизация
* тип переменной
* размер переменной, размер типа
* типы <code>int</code>, <code>char</code>: типичные размеры. Например, на архитектуре <code>x86_64</code> под Linux в компиляторе <code>GCC</code>.

## Основные конструкции языков C и C++
* объявления переменных
* выражения и операторы:
  * арифметические (`+`, `-`, `*`, `/`, `%`, `+=`, `-=`, `*=`, `/=`, `%=`, `++`, `--`)
  * булевы (`<`, `<=`, `>`, `>=`, `==`, `!=`, `&&`, `||`, `!`)
  * на минимальную оценку необязательно знать: отличия постфиксных и префиксных операторов
* условные операторы `if`, `switch` (с `break` и fallthrough, включая проблему с инициализацией переменных)
* циклы `for`, `while`

## Функции
* объявление и определение функции, требуется отличать между собой (можно случайно перепутать, но после вопроса исправиться)
* вызов функции (синтаксис, не нужно знать mangling, конвенции вызовов)
* возвращаемое значение
* рекурсивный вызов

## Основные конструкции C++
* синтаксис `static_cast`
* синтаксис объявления пространств имён, обращения к элементу внутри пространства имён
* `auto` для объявления переменных
* range-based for, в том числе с `auto&` и `const auto&`
* синтаксис шаблонов, достаточный для написания минимального адаптера `stack<T>` поверх `deque`

## Классы
* определение класса, конструктор, деструктор, методы
* специальные методы (пять штук), правило нуля, правило пяти
* приватные/защищённые/публичные поля и методы
* наследование: базовый синтаксис, включая вызов конструктора базового класса

## Полиморфные классы
* виртуальные методы и их отличия от невиртуальных
* необходимость виртуального деструктора
* чисто виртуальные функции, что происходит при отсутствии `override` или `virtual`
* slicing (срезка объектов) при присваивании полиморфного класса в переменную типа "базовый класс", как защититься (хранить только ссылки/умные указатели)
* хранение полиморфных объектов в контейнерах
* `dynamic_cast` для полиморфных классов (по указателям и ссылкам)

## Const correctness
* синтаксис константных ссылок, применение при передаче аргументов
* невозможность изменять константные объекты и их поля
* const-qualifier у методов (const member function), перегрузка по const-qualifier (const overloading)

## Использование move-семантики
* эффективная инициализация полей класса из аргументов, принятых по значению или по rvalue-ссылке
* moved-from состояние у объектов: может быть не определено, может быть невозможно обнаружить, пример ошибки
* отсутствие необходимости `move` из результата функции, возвращённого по значению
* необходимость move для явной передачи владения `unique_ptr`
* почему `std::move` не выполняет никакого кода

## STL
* использование `vector` как динамического массива фиксированной длины, <code>push_back</code> и <code>emplace_back</code>
* использование `map` со стандартным компаратором, особенность <code>operator[]</code> (создаёт значение даже при чтении)
* `lower_bound`/`upper_bound`: параметры, возвращамое значение

## Си
* использование строк в стиле Си: отличия `char s[10]` и `const char *s`, преобразование в две стороны для `std::string`
* операции со строками в стиле Си: конкатенция, получение длины, безопасная альтернатива для `gets` и `scanf("%s")`
* массивы массивов в языке Си (вроде `int**`): выделение, освобождение, использование

## Исключения
* синтаксис `try`/`catch`/`throw`, включая `catch (...)` и `throw;` (но без function-try-block)
* раскрутка стека: автоматический вызов деструкторов, в том числе в `new`/`new[]`, конструкторе, конструкторах полей
* необходимость ловить исключения по ссылке
* exception safety: определения no/basic/strong/nothrow
* умение добавить базовую гарантию в произвольный код при помощи автоматических выполняемых деструкторов

## Многопоточность
* базовое использование `thread` (включая `join()`), `mutex` и `unique_lock`
* гонки: пример гонки данных и гонки при выводе на экран, как избежать, умение видеть гонки в произвольном несложном коде

# Билеты
## 1x. Продвинутый синтаксис
`14-220110`, `20-220221`, `21-220228`, `27.5-220519`, `30-220606`

TODO

### 10. Move-семантика

## 2x. Шаблоны
`14-220110`, `22-220314`, `23-220321`, `27.5-220519`

TODO

## 3x. Исключения
`15-220117`, `16-220124`, кусочки `30-220606`

TODO

## 4x. Многопоточность и сети
`17-220131`, `18-220207`, кусочки `19-220214` и `20-220221`

### 40. TCP-соединения при помощи блокирующего ввод-вывода в Boost::Asio
* Чем характеризуется TCP-соединение: две пары (хост с IPv4-адресом, порт)
* Почему порт сервера обычно фиксирован, а клиента — случаен
* Использование `boost::asio::ip::tcp::iostream` на сервере и на клиенте для создания простого эхо-сервера
* Отличия `local_endpoint()` от `remote_endpoint()`

### 41. Базовая многопоточность
* Создание потоков в C++11, передача аргументов в функцию потока по значению и ссылкам
* Joinable/detached потоки
* Гонки: при выводе на экран, по данным, одновременное чтение без записей
* Борьба с гонками: мьютексы, атомарные снимки, RAII-обёртка над мьютексом (`unique_lock`)
* Частичная потокобезопасность `cout`

### 42. Оповещение о событиях
* Формализм happens-before, неочевидные примеры нарушения и выполнения, возможный reordering
* Условные переменные: как использовать, spurious wakeup
* Реализация producer-consumer
* Ключевое слово `mutable`

### 43. Дизайн многопоточных приложений
* Deadlock, reentrant-функции, `recursive_mutex`, отделение приватного API без блокировок от публичного API с блокировками
* Взаимные блокировки и их избегание при помощи контроля порядка взятия блокировок или `scoped_lock`/`unique_lock`
* Ключевое слово `thread_local` в сравнении с глобальными переменными
* Частичная потокобезопасность `shared_ptr`
* Проблема TOCTOU

## 5x. Совместимость с языком программирования Си
`19-220214`, `20-220221`, `24-220411`, `25-220418`, `26-220425`, `27.5-220519`

TODO

## 6x. Метапрограммирование
`27-220516`, `28-220523`, `29-220530`,

TODO

## Явно исключено
* иерархия итераторов и их виды
* `::operator new` и их перегрузка
* аллокаторы
* использование виртуального наследования для ABC (abstract base class)
* определения паттернов "Стратегия" и "Фабрика"
* TCP: возможность не получить сообщение целиком за один вызов `receive`, почему это неважно для `tcp::iostream`
